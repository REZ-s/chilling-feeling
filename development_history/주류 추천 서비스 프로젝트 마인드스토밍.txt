< 주류 구독 추천 서비스 >
주 단위 주류 구독 추천 서비스 
기존 어플과의 차별성 : 사용자의 기분, 장소 (홈술 or 회식 등), 컨디션 (술의 도수)에 따른 맞춤 주류 구독 배송 서비스
참고용 기존 어플 : 퍼플독 (와인 구독배송서비스), 술담화 (전통주 구독배송서비스), 데일리샷 (맥주 구독서비스 - 오프라인용)



# 제약사항
1. 주류는 온라인 판매가 법적으로 불가 (전통주는 가능, 세금 및 세율을 포함한 해외직구는 가능)
-> 해당 판매처 사이트로 링크를 하는 방향으로 결정
2. 직접 배송하는 기능은 현실적으로 어려움
-> 추천 및 구독까지만 하는 것으로 결정



# 구현해야할 기능
[Back-end]
주단위 구독하기 기능 
배송하기 기능
회원가입 (필요한 이유 : 선호도 / 히스토리 / 즐겨찾기 / 장바구니 데이터 저장)
로그인
주류 종류별로 데이터 입력 (소주, 맥주, 와인, 위스키, 브랜디, 럼, 데킬라 등)
주류 카테고리화 (종류에 따른 단순 정량적 분류 / 예: 레드와인, 화이트와인)
주류 카테고리화 (목적에 따른 선호도에 따른 정성적 분류 / 예: 파티에서 많이 마시는 술, 혼술용으로 많이 마시는 술)
사용자 맞춤 서베이 질문 리스트 (기분 : 업된, 잔잔한, 우울한, 먹고죽자 / 목적 : 혼술, 파티, 미팅 / 상태 : 팔팔한, 보통의, 피곤한)
- 우울하고 피곤한 경우, 말뿐이라도 같이 먹으면 좋을 음식을 추천해주는 것도 좋겠다. (이때 먹는 술은 선호도에 따라 선택)
  예: 아래와 같은 음식과 같이 먹으면 좋아요 :) 
사용자 맞춤 서베이에 따른 추천하기 기능 (추천시스템 알고리즘 오픈소스 활용)

[Front-end]
메인 화면
로그인 화면
회원가입 화면
회원정보 화면 
구독정보 화면
검색 화면

1. 직접 고르기
카테고리별 화면
즐겨찾기 화면

2. 추천
사용자 맞춤 서베이 질문 화면 (iframe)
추천 시스템에 의한 선별된 카테고리별 화면



# 설계 방향
우선 처음에 추천 알고리즘의 정확도에 신경 쓸 필요는 없다. 맨 나중에 생각한다.
백엔드 기능의 구현에 집중한다. 
구독하기 기능은 기한은 무제한이다. 즉, 사용자가 매달 결제하고, 구독해지를 하고 싶으면 언제든지 해지하면 된다.

기능 다이어그램을 그려본다.
- 각 기능에 대한 데이터 모델링

<플로우 차트>
(로그인 상태) 구독 -> 구독상품선택 -> 결제진행
(로그아웃 상태) 구독 -> [로그인 플로우] -> 구독상품선택 -> 결제진행

로그인 -> 정상 프로세스 진행
로그인 -> 실패 -> 아이디 및 비밀번호 찾기 -> 정상 프로세스 진행
로그인 -> 실패 -> 아이디 및 비밀번호 찾기 -> 실패 -> '고객센터 문의'
로그인 -> 실패 -> 아이디 및 비밀번호 찾기 -> 실패 -> 회원가입
로그인 -> 실패 -> 회원가입
회원가입 -> 정상 프로세스 진행
회원가입 -> 실패

결제 -> 실패
결제 -> 정상 프로세스 진행

(로그인 상태) 추천 -> 맞춤서베이 -> (추천된) 상품 보기
보기 -> 카테고리별 (all, 소주, 맥주, 와인, ...) 상품 보기
검색 -> (해당 글자가 들어간) 상품 보기
즐겨찾기 -> (즐겨찾기된) 상품 보기


<도메인 모델>
회원, 상품(주류), 구독(결제), 검색, 히스토리, 즐겨찾기, 맞춤서베이(CustomSurvey), 구독상품(술 종류별로 가격이 다르겠다)

<테이블 설계>
회원 (id, pw, 이름, 주소, 전화번호, 구독 리스트)
상품 (id, 이름, 가격, 재고, 타입, 구독상품, 카테고리) : * 타입은 와인, 양주, 전통주 3가지 중 하나이다.
구독 (id, 회원, 구독상품, 구독날짜, 구독상태) : * 구독상태는 구독중, 구독취소예정, 구독취소완료 3가지 중 하나이다. 
구독상품 (id, 구독, 상품 리스트, 가격) : * 구독하면 매 주 지급되는 상품은 패키지형태로 지급된다. 이 패키지 안의 개별 상품들은 중복될 수 있다.
즐겨찾기 (id, 회원, 상품 리스트) : * 검색과 추천은 실시간 로직으로 결정되기때문에 회원별로 해당 정보를 따로 저장하진 않는다.
카테고리 (id, 이름, 상품 리스트, 상위 카테고리, 하위 카테고리 리스트)

상품 (id, 이름, 가격, 재고, 타입)
-> 상품 (id, 이름, 가격, 재고, 타입, 구독상품, 카테고리)
위와 같이 변경해도 될까?

상품, 카테고리 도메인 코드 작성 해야함.
@ManyToMany 를 풀어서 작성해야할듯


< DB 스키마 및 테이블 설계 > 
회원 스키마를 만들고, 그 안에 회원 관련 테이블을 생성하자. (일종의 패키지화 / 규모가 아직 작으므로 DataSource 분리는 안함)
(DB마다 스키마나 카탈로그중 그룹화하는게 다르므로 둘 중 하나 사용)
예) CoreDB 의 Member Schema 의 User Table
     코드상으로 @Table(schema = "member", name = "user") 

회원(Member) - 회원가입 및 로그인과 관련된 스키마
    사용자 (user) - user_id : UUID, user_name, account_type
    프로필 (profile) - profile_id, user_id, nickname, image_url, introduction, join_date, update_date
    인증 (authentication) - authentication_id, user_id, gather_agree, phone_number, email, birthday, sex, nation, auth_date
    구독 (subscription) - subscription_id, user_id, subscription_plan, purchase_date, expriation_date
    장치 (device) - device_id, user_id, in_use, register_no, uuid, model, os_type, os_version
    
인증(Auth) - 인증용 스키마
    소셜로그인 (social_login) - social_login_id, user_id, social_code, external_id, access_token, update_date
    패스워드 (password) - password_id, user_id, salt, password, update_date
    cidi (cidi) - cidi_id, user_id, ci, di
   
로그(Log) - 로깅용 스키마
    사용자 활동 로그 (user_activity_log) - user_activity_log_id, user_id, table_name, row_id, activity_code, as_is, to_be, modifier, log_time
    로그인 로그 (user_login_log) - user_login_log_id, user_id, status_code, device_id, ip, fail_count, fail_reason, login_date
    휴면 로그 (user_dormant_log) - user_dormant_log_id, user_id, status_code, dormant_date
    탈퇴 로그 (user_withdrawal_log) - user_withdrawal_log_id, user_id, status_code, ci, reason_code, reason_text, withdrawal_date

휴면(Dormant) - 휴면 계정용 스키마

탈퇴(Withdrawal) - 탈퇴 계정용 스키마


< 테이블 정의서 설명 > 
user_id : '00000000-0000-0000-0000-000000000000' 형태의 임의 난수
user_name : 실제 로그인할 때 사용하는 id 문자열 
account_type : 99 (관리자 계정) / 1 (일반 사용자 계정) / 2 (내부 테스트용 계정) / 3 (임시 계정)
gather_agree : 개인 정보 수집 동의 여부 (0 : 동의하지 않음 / 1 : 동의)
subscription_plan : 구독 결제한 개월 수 (최소 단위 1달)



<가상 트래픽 설정>
평균 초당 10000번의 메인화면 홈페이지 로딩
평균 초당 1000번의 검색
평균 초당 10번의 추천

< 개발 순서 >
노트북과 PC에서 소스코드를 개발해서 로컬환경에서 테스트
마지막에 AWS 서버로 옮긴다.



