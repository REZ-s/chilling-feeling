(1) 일반적인 ip 추적 : HttpServletRequest의 getRemoteAddr() 

public class RequestRateLimiter {
    private final int maxRequests;  // 최대 요청 수
    private final int timeInterval; // 일정 시간 동안

    // 생성자를 통해 요청 제한 기준을 설정
    public RequestRateLimiter(int maxRequests, int timeInterval) {
        this.maxRequests = maxRequests;
        this.timeInterval = timeInterval;
    }

    // 클라이언트의 IP 주소와 요청 횟수를 추적하는 메서드
    public void trackRequest(String clientIp) {
        // 구현: 클라이언트의 IP 주소와 요청 횟수를 추적하여 저장하거나 업데이트합니다.
    }

    // 클라이언트의 접근 여부를 확인하는 메서드
    public boolean allowRequest(String clientIp) {
        // 구현: 클라이언트의 IP 주소와 저장된 요청 횟수를 비교하여 접근 여부를 결정합니다.
        // 제한에 도달한 경우 false를 반환하고, 그렇지 않은 경우 true를 반환합니다.
    }
}



public class RequestRateLimitFilter extends OncePerRequestFilter {
    private final RequestRateLimiter rateLimiter;

    // 생성자를 통해 RequestRateLimiter를 주입받습니다.
    public RequestRateLimitFilter(RequestRateLimiter rateLimiter) {
        this.rateLimiter = rateLimiter;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String clientIp = request.getRemoteAddr(); // 클라이언트의 IP 주소 추출
        rateLimiter.trackRequest(clientIp); // 추적하여 저장 또는 업데이트
        if (!rateLimiter.allowRequest(clientIp)) {
            response.sendError(HttpServletResponse.SC_TOO_MANY_REQUESTS); // 요청 제한에 도달한 경우 429 Too Many Requests 상태코드 반환
            return;
        }

        filterChain.doFilter(request, response); // 다음 필터 또는 요청 처리를 진행
    }
}



@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final RequestRateLimiter rateLimiter;

    // 생성자를 통해 RequestRateLimiter를 주입받습니다.
    public SecurityConfig(RequestRateLimiter rateLimiter) {
        this.rateLimiter = rateLimiter;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .addFilterBefore(new RequestRateLimitFilter(rateLimiter), UsernamePasswordAuthenticationFilter.class)
            .authorizeRequests()
            // 권한 설정
            .anyRequest().authenticated()
            .and()
            .formLogin()
            .and()
            .logout();
    }
}




(2) X-Forwarded-For 헤더를 이용해서 실제 클라이언트의 ip 추적

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.filter.ForwardedHeaderFilter;

@Configuration
public class WebConfig {
    @Bean
    public FilterRegistrationBean<ForwardedHeaderFilter> forwardedHeaderFilter() {
        FilterRegistrationBean<ForwardedHeaderFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new ForwardedHeaderFilter());
        registrationBean.setOrder(0); // 필터 순서 설정
        return registrationBean;
    }
}

public class RequestRateLimitFilter extends OncePerRequestFilter {
    private final RequestRateLimiter rateLimiter;

    public RequestRateLimitFilter(RequestRateLimiter rateLimiter) {
        this.rateLimiter = rateLimiter;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String clientIp = request.getHeader("X-Forwarded-For"); // X-Forwarded-For 헤더에서 클라이언트 IP 주소 추출
        if (clientIp == null) {
            clientIp = request.getRemoteAddr(); // X-Forwarded-For 헤더가 없는 경우 기본적인 방법으로 추출
        }
        rateLimiter.trackRequest(clientIp);
        if (!rateLimiter.allowRequest(clientIp)) {
            response.sendError(HttpServletResponse.SC_TOO_MANY_REQUESTS);
            return;
        }

        filterChain.doFilter(request, response);
    }
}





(3) X-Real-IP 헤더를 이용해서 실제 클라이언트 ip 추적

public class RequestRateLimitFilter extends OncePerRequestFilter {
    private final RequestRateLimiter rateLimiter;

    public RequestRateLimitFilter(RequestRateLimiter rateLimiter) {
        this.rateLimiter = rateLimiter;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String clientIp = request.getHeader("X-Real-IP"); // X-Real-IP 헤더에서 클라이언트 IP 주소 추출
        if (clientIp == null) {
            clientIp = request.getRemoteAddr(); // X-Real-IP 헤더가 없는 경우 기본적인 방법으로 추출
        }
        rateLimiter.trackRequest(clientIp);
        if (!rateLimiter.allowRequest(clientIp)) {
            response.sendError(HttpServletResponse.SC_TOO_MANY_REQUESTS);
            return;
        }

        filterChain.doFilter(request, response);
    }
}

